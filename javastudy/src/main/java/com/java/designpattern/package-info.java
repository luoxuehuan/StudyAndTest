/**
 * 
 */
/**
 * @author lxh
 * 
 * 设计模式案例
 * 
 * 设计模式：
 * 	1.简单工厂模式
 * 		优点：工厂类中包含了必要的逻辑判断,根据客户端的选择条件动态实例化相关的类。对于客户端来说，去除了具体产品的依赖。
 *  2.策略模式
 * 	3.单例模式
 * 		懒汉式.  比较懒,有人来,才创建 
 * 		饿汉式.  饿了,直接创建好。{@link}
 * 	4.装饰模式
 * 		解释：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。
 * 		把4个动作放到一起做。
 * 		案例： IO的Buffer.缓存是装饰模式的。  
 * 			动态的给inputsteam 增加 缓存功能。把inputstream作为bufferreader的一个成员变量。
 *  5.建造者模式
 *  	建造的过程是稳定的
 * 
 * 	6.享元模式
 * 		案例.Spring的Bean Service 就是享元模式。而不是单例模式。
 * 
 * 	7.代理模式Proxy
 * 		解释：为其他对象提供一种代理以控制对这个对象的访问。
 * 		
 * 		Proxy类,保存一个引用使得代理可以访问实体,并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体RealSubject。
 * 		比喻：A要送C花,A不认识C,所以让B代替送。 最后B和C在一起了。   代理就是真实对象的引用。
 * 		使用场景：
 * 			远程代理。
 * 			虚拟代理。浏览器用代理模式优化加载。
 * 			安全代理。
 * 			智能指引。
 * 		思考： 代理模式和装饰模式有是区别? 装饰加了功能。代理是保留对真实对象的一个引用。
 * 
 * 	8.工厂方法模式Factory Method
 * 		定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
 * 		抽象工厂。 加法工厂。减法工厂。乘法工厂。除法工厂。
 * 		运算类。 加法类。 乘法类。减法类。除法类。
 * 
 * 		优点：克服了简单工厂的违背开发-封闭的缺点。又保持了封装对象创建过程的优点。
 * 		扩展： 反射。
 * 	9.职责链模式
 * 
 * 	10.模板方法模式
 * 	11.建造者模式
 * 	12.抽象工厂模式
 * 	
 * 
 * 
 * 
 * 
 * 
 * 
 * 设计原则：
 * 1.单一职责原则
 * 2.封闭开放原则
 * 		不能修改,可以扩展。
 * 3.依赖倒置原则
 * 		高层模块不要依赖底层模块。两个都应该依赖抽象。
 * 4.里氏代换原则
 * 		子类型必须可以替换父类型
 * 		比如： 鸟会飞，企鹅不会飞，企鹅不能以子类身份出现。
 * 5.接口隔离原则（Interface Segregation Principle）
 * 		定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
 * 		问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
 * 		解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。	
 *
 * 6.迪米特法则（Law Of Demeter）又叫最少知道原则
 * 		定义：一个对象应该对其他对象保持最少的了解。
 * 		问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
 * 		解决方案：尽量降低类与类之间的耦合。
 */
package com.java.designpattern;